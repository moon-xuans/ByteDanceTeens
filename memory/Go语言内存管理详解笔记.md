### Go语言内存管理详解笔记

#### 1.前言

**性能优化是什么？**

提升软件系统处理能力，减少不必要的消耗，充分发掘计算机算力

**为什么要做性能优化？**

1.用户体验：带来用户体验的提升；

2.资源高效利用：降低成本，提高效率；

**性能优化的层面**

业务层优化：

- 针对特定场景，具体问题，具体分析
- 容易获得较大性能收益

语言运行时优化：

- 解决更通用的性能问题
- 考虑更多场景
- Tradeoffs(权衡)

数据驱动：

- 自动化性能分析工具 —— pprof
- 依靠数据而非猜测
- 首先优化最大瓶颈

#### 2.自动内存管理

动态内存：

- 程序在运行时根据需求动态分配的内存：malloc()

自动内存管理(垃圾回收)：由程序语言的运行时系统管理动态内存

- 避免手动内存管理，专注于实现业务逻辑
- 保证内存使用的正确性和安全性

三个任务：

- 为新对象分配空间
- 找到存活对象
- 回收死亡对象的内存空间

##### 2.1.相关概念

- Mutator：业务线程，分配新对象，修改对象指向关系
- Collector：GC线程，找到存活对象，回收死亡对象的内存空间
- Serial GC：只有一个collector
- Parallel GC：支持多个collectors同时回收的GC算法
- Concurrent GC：mutators和collectors可以同时执行
  - collectors必须感知对象指向关系的改变





- 评价GC算法
  - 安全性：不能回收存活的对象 (基本要求)
  - 吞吐率：1 - GC时间/程序执行总时间(花在GC上的时间)
  - 暂停时间：业务是否感知
  - 内存开销：GC元数据开销
- 追踪垃圾回收
- 引用计数

##### 2.2.追踪垃圾回收

- 对象被回收的条件：指针指向关系不可达的对象
- 标记根对象
  - 静态变量、全局变量、常量、线程栈等
- 标记：找到可达对象
  - 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
-  清理：所有不可达对象
  - 将存活对象复制到另外的内存空间
  - 将死亡对象的内存标记为“可分配”
  - 移动并整理存活对象
- 根据对象的生命周期，使用不同的标记和清理策略
  - Copying GC:将对象复制到另外的内存空间
  - Mark-sweep GC:使用free list管理空闲内存
  - Compact GC：原地整理对象

##### 2.3.分代GC

- 分代假说
- Intuition：很多对象在分配出来后很快就不再使用了
- 每个对象都有年龄：经历过GC的次数
- 目的：对年轻和老年的对象，制定不同的GC策略，降低整体内存管理的开销
- 不同年龄的对象处于heap的不同区域



- 年轻代
  - 常规的对象分配
  - 由于存活对象很少，可以采用copying collection
  - GC吞吐率很高
- 老年代
  - 对象趋向于一直活着，反复复制开销较大
  - 可以采用mark-sweep collection

##### 2.4.引用计数

- 每个对象都有一个与之关联的引用数目
- 对象存活的条件：当且仅当引用数大于0
- 优点：
  - 内存管理的操作被平摊到程序执行过程中
  - 内存管理不需要了解runtime的实现细节：C++智能指针
- 缺点：
  - 维护引用计数的开销较大：通过原子操作保证对引用计数操作的原子性和可见性
  - 无法回收环形数据结构
  - 内存开销：每个对象都引入的额外内存空间存储引用数目
  - 回收内存时依然可能引发暂停

#### 3.内存管理及优化

##### 3.1.分块

- 目标：为对象在heap上分配内存
- 提前将内存分块
  - 调用系统调用mmap()向OS申请一大块内存
  - 先将内存划分成大块，称作mspan
  - 再将大块继续划分成特定大小的小块，用于对象分配
  - noscan mspan：分配不包含指针的对象——GC不需要扫描
  - scan mspan：分配包含指针的对象——GC需要扫描
- 对象分配：根据对象的大小，选择最合适的块返回

##### 3.2.缓存

- TCMalloc:thread caching
- 每个p包含一个mcache用于快速分配，用于为绑定于p上的g分配对象
- mcache管理一组mspan
- 当mcache中的mspan分配完毕，向mcentral申请带有未分配块的mspan
- 当mspan中没有分配的对象，mspan会被缓存到mcentral中，而不是立刻释放并归还给OS



- 对象分配是非常高频的操作：每秒分配GC级别的内存
- 小对象占比较高
- Go内存分配比较耗时
  - 分配路径长：g -> m -> p -> mcache -> mspan -> memory block -> return pointer
  - pprof：对象分配的函数是最频繁调用的函数之一

##### 3.3.优化方案：Balanced GC

- 每个g都绑定一大块内存，称作goroutine allocation buffer(GAB)

- GAB用于noscan类型的小对象分配: < 128 B

- 使用三个指针维护GAB：base， end， top

- Bump pointer(指针碰撞)风格对象分配

  - 无须和其他分配请求互斥
  - 分配动作简单高效



- GAB对于Go内存管理来说是一个大对象
- 本质：将多个小对象的分配合并成一次大对象的分配
- 问题：GAB的对象分配方式会导致内存被延迟释放
- 方案：移动GAB中存活的对象
  - 当GAB总大小超过一定阈值时，将GAB中存活的对象复制到另外分配的GAB中
  - 原先的GAB可以释放，避免内存泄漏
  - 本质：用copying GC的算法管理小对象

#### 4.编译器和静态分析

##### 4.1.编译器的结构

- 重要的系统软件
  - 识别符合语法和非法的程序
  - 生成正确且高效的代码
- 分析部分（前端front end）
  - 词法分析，生成词素(lexeme)
  - 语法分析，生成语法树
  - 语义分析，收集类型信息，进行语义检查
  - 中间代码生成
- 综合部分（后端 back end）
  - 代码优化，机器无关优化，生成优化后的IR
  - 代码生成，生成目标代码

##### 4.2.静态分析

- 静态分析：不执行程序代码，推导程序的行为，分析程序的性质
- 控制流：程序执行的流程
- 数据流：数据在控制流上的传递
- 通过分析控制流和数据流，我们可以知道更多关于程序的性质

##### 4.3.过程内分析和过程间分析

- 过程内分析
  - 仅在函数内部进行分析
- 过程间分析
  - 考虑过程调用时参数传递和返回值的数据流和控制流
- 为什么过程间分析是个问题？
  - 需要通过数据流分析才能知道接口的实现的具体类型
  - 根据具体类型，产生了新的控制流
  - 过程间分析需要同时分析控制流和数据流 —— 联合求解，比较复杂

#### 5.编译器优化

- 为什么做编译器优化
  - 用户无感知，重新编译即可获得性能收益
  - 通用性优化
- 现状
  - 采用的优化少
  - 编译时间较短，没有进行较复杂的代码分析和优化
- 编译优化的思路
  - 场景：面向后端长期执行任务
  - Tradeoff：用编译时间换取更高效的机器码
- Beast mode
  - 函数内联
  - 逃逸分析
  - 默认栈大小调整
  - 边界检查消除
  - 循环展开

##### 5.1.函数内联

- 内联：将被调用函数的函数体的副本替换到调用位置上，同时重写代码以反映参数的绑定
- 优点：
  - 消除函数调用开销，例如传递参数、保存寄存器等
  - 将过程间分析转换为过程内分析，帮助其他优化，例如逃逸分析
- 函数内联能多大程序影响性能？——使用micro-benchmark验证一下
- 缺点：
  - 函数体变大，instruction cache不友好
  - 编译生成的Go镜像变大
- 函数内联在大多数情况下是正向优化

##### 5.2.Beast Mode

- Go函数内联受到的限制较多
  - 语言特性，例如interface,defer等，限制了函数内联
  - 内联策略非常保守
- Beast mode：调整函数内联的策略，使更多函数被内联
  - 降低函数调用的开销
  - 增加了其他优化的机会：逃逸分析
- 开销
  - Go镜像增加~10%
  - 编译时间增加

##### 5.3.逃逸分析

- 逃逸分析：分析代码中指针的动态作用域：指针在何处可以被访问
- 大致思路
  - 从对象分配处出发，沿着控制流，观察对象的数据流
  - 若发现指针p在当前作用域s
    - 作为参数传递给其他函数
    - 传递给全局变量
    - 传递给其他goroutine
    - 传递给已逃逸的指针指向的对象
  - 则指针p指向的对象逃逸出s。反之则没有逃逸出s
- Beast mode:函数内联拓展了函数边界，更多对象不逃逸
- 优化：未逃逸的对象可以在栈上分配
  - 对象在栈上分配和回收很快：移动sp
  - 减少在heap上的分配，降低GC负担。

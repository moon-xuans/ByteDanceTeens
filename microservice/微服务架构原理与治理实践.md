### 微服务架构原理与治理实践

#### 01.微服务架构介绍

##### 1.1.系统架构演变历史

**为什么系统架构需要演进？**

- 互联网的爆炸性发展
- 硬件设施的快速发展
- 需求复杂性的多样化
- 开发人员的急剧增加
- 计算机理论及技术的发展

单体架构 -> 垂直应用架构 -> 分布式架构 -> SOA架构 -> 微服务架构

##### 1.2.微服务架构概览

![](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203091703830.png)

彻底的服务化

优势：

- 开发效率
- 业务独立设计
- 自下而上
- 故障隔离

劣势：

- 治理、运维难度
- 观测挑战
- 安全性
- 分布式系统

##### 1.3.微服务架构核心要素

- 服务治理
  - 服务注册
  - 服务发现
  - 负载均衡
  - 扩缩容
  - 流量治理
  - 稳定性治理
- 可观测性
  - 日志采集
  - 日志分析
  - 监控打点
  - 监控大盘
  - 异常报警
  - 链路追踪
- 安全
  - 身份验证
  - 认证授权
  - 访问令牌
  - 审计
  - 传输加密
  - 黑产攻击

#### 02.微服务架构原理及特征

##### 2.1.基本概念

服务(service):一组具有相同逻辑的运行实体。

实例(instance):一个服务中，每个运行实体即为一个实例。

实例与进程的关系：实例与进程之间没有必然对应关系，可以一个实例对应一个或多个进程(反之不常见)。

集群(cluster)：通常指服务内部的逻辑划分，包含多个实例。

常见的实例承载形式：进程、VM、k8s pod

有状态/无状态服务：服务的实例是否存储了可持久化的数据(例如磁盘文件)。

![image-20230203092250254](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203092250254.png)

**服务间通信**

对于单体服务，不同模块通信只是简单的函数调用。对于微服务，服务间通信意味着网络传输。

##### 2.2.服务注册及发现

> 在代码层面，指定调用一个目标服务的地址的存在问题：
>
> - 本地DNS存在缓存，导致延时
> - 负载均衡问题
> - 不支持服务实例的探活检查
> - 域名无法配置端口

解决思路：新增一个统一的服务注册中心，用于存储服务名到服务实例的存储。

##### 2.3.流量特征

- 统一网关入口
- 内网通信多数采用RPC
- 内网调用链路

#### 03.核心服务治理功能

##### 3.1.服务发布

服务发布(deployment),即指让一个服务升级运行新的代码的过程。

服务发布的难点：1.服务不可用；2.服务抖动；3.服务回滚

**解决方案**

###### 3.1.1.蓝绿部署

![image-20230203092943416](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203092943416.png)

特点：简单，稳定，但需要两倍资源

###### 3.1.2.灰度发布(金丝雀发布)

![image-20230203093153907](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203093153907.png)

##### 3.2.流量治理

在微服务架构下，可以基于地区、集群、实例、请求等维度，对端到端流量的路由路径进行精确控制。

![image-20230203093544318](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203093544318.png)

##### 3.3.负载均衡

负载均衡负责分配请求在每个下游实例上的分布。

##### 3.4.稳定性治理

线上服务总是会出问题的，这与程序的正确性无关。

经常出现的问题：

- 网络攻击
- 流量突增
- 机房断电
- 光纤被挖
- 机器故障
- 网络故障
- 机房空调故障

微服务架构中典型的稳定性治理功能：

- 限流
- 熔断
- 过载保护
- 降级

#### 04.字节跳动服务治理实践

##### 4.1.重试的意义

**本地函数调用**

可能有哪些异常？

- 参数非法
- OOM
- NPE
- 边界case
- 系统崩溃
- 死循环
- 程序异常退出

**远程函数调用**

可能有哪些异常？

- 网络抖动
- 下游负载高导致超时
- 下游机器宕机
- 本地机器负载高，调度超时
- 下游熔断、限流

意义：重试可以避免掉偶发的错误，提高SLA

- 降低错误率：假设单次请求的错误概率为0.01，那么连续两次错误概率则为0.0001
- 降低长尾延时：对于偶尔耗时较长的请求，重试请求有机会提前返回
- 容忍暂时性错误：某些时候系统会有暂时性异常(例如网络抖动)，重试可以尽量规避
- 避开下游故障实例：一个服务中可能会有少量实例故障(例如机器故障)

##### 4.2.重试的难点

- 幂等性
- 重试风暴
- 超时设置

重试风暴：

![image-20230203095645538](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203095645538.png)

##### 4.3.重试策略

###### 4.3.1.限制重试比例

设定一个重试比例阈值(例如1%),重试次数占所有请求比例不超过该阈值。

![image-20230203095929034](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203095929034.png)

###### 4.3.2.防止链路重试

链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试。可以返回特殊的status表明“请求失败， 但别重试”

![image-20230203100532870](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203100532870.png)

###### 4.3.3.Hedged requests

对于可能超时(或延时高)的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应。

![image-20230203100844365](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203100844365.png)

##### 4.4.重试效果验证

实际验证经过上述重试策略后，在链路上发生的重试放大效应。

![image-20230203100956146](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2023/image-20230203100956146.png)

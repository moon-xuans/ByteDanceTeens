## 高质量编程与性能调优实践

### 1.高质量编程

#### 1.1.编码规范

**如何编写高质量的Go代码**

- 代码格式
- 注释
- 命名规范
- 控制流程
- 错误和异常处理

##### 1.1.1.代码格式

gofmt:自动化格式代码

goimports:自动增删依赖的包引用、将依赖包按字母序排序并分类

##### 1.1.2.注释

**注释应该做的：**

- 解释代码作用 —— 适合注释公共符号
- 解释代码如何做的 —— 适合注释实现过程
- 解释代码实现的原因 —— 适合解释代码的外部因素，并提供额外上下文
- 解释代码什么情况会出错 —— 适合解释代码的限制条件

**公共符号始终要注释**

- 包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释
- 任何既不明显也不简短的公共功能必须予以注释
- 无论长度或复杂程度如何，对库中的任何函数都必须进行注释

**公共符号始终要注释**

- 有一个例外，不需要注释实现接口的方法。

##### 1.1.3.命名规范

**variable**

- 简洁胜于冗长
- 缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写
- 变量距离其被使用的地方越远，则需要携带的上下文信息

**function**

- 函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的
- 函数名尽量简短
- 当名为foo的包某个函数返回类型Foo时，可以省略类型信息而不导致歧义
- 当名为foo的包某个函数返回类型T时，可以在函数名中加入类型信息

**package**

- 只由小写字母组成。不包含大写字母和下划线等字符
- 简短并包含一定的上下文信息
- 不要与标准库同名

以下规则尽量满足：

- 不使用常量变量名作为包名
- 使用单数而不是复数
- 谨慎地使用缩写

##### 1.1.4.控制流程

- 避免嵌套，保持正常流程清晰
- 尽量保持正常代码路径为最小缩进

##### 1.1.5.错误和异常处理

**简单错误**

- 简单的错误指的是仅出现一次的错误，且在其他地方不需要捕获该错误
- 优先使用errors.New来创建匿名变量来直接表示简单错误
- 如果有格式化的需求，使用fmt.Errorf

**错误的Wrap和Unwrap**

- 错误的Wrap实际上是提供了一个error嵌套另一个error的能力，从而生成一个error的跟踪链
- 在fmt.Errorf中使用：%w关键字来将一个错误关联至错误链中

**错误判定**

- 判定一个错误是否为特定错误，使用error.Is
- 不同于使用==，使用该方法可以判定错误链上的所有错误是否含有特定的错误
- 在错误链上获取特定种类的错误，使用errors.As

**panic**

- 不建议在业务代码中使用panic
- 调用函数不包含recover会造成程序崩溃
- 若问题可以被屏蔽或解决，建议使用error代替panic
- 当程序启动阶段发生不可逆转的错误时，可以在init或main函数中使用panic

**recover**

- recover只能在被defer的函数中使用
- 嵌套无法生效
- 只在当前goroutine生效
- defer的语句是后进先出
- 如果需要更多的上下文信息，可以recover后在log中记录当前的调用栈

#### 1.2.性能优化建议

##### 1.2.1.Benchmark

性能表现需要实际数据衡量

Go语言提供了支持基准性能测试的benchmark工具

##### 1.2.2.Slice

**slice预分配内存**

尽可能在使用make()初始化切片时提供容量信息

**另一个陷阱：大内存未释放**

- 在已有切片基础上创建切片，不会创建新的底层数组
- 场景：1.原切片较大，代码在原切片基础上新建小切片；2.原底层数组在内存中有引用，得不到释放
- 可使用copy替代re-slice

##### 1.2.3.Map

map预分配内存

##### 1.2.4.字符串处理

**使用strings.Builder**

- 常见的字符串拼接方式
- 使用 + 拼接性能最差，strings.Builder,bytes.Buffer相近，strings.Buffer更快

##### 1.2.5.空结构体

**使用空结构体节省内存**

- 空结构体struct{}实例不占据任何的内存空间
- 可作为各种场景下的占位符使用

##### 1.2.6.atomic包

**使用atomic包**

- 锁的实现是通过操作系统来实现，属于系统调用
- atomic操作是通过硬件实现，效率比锁高
- sync.Mutex应该用来保护一段逻辑，不仅仅用于保护一个变量
- 对于非数值操作，可以使用atomic.Value，能承载一个interface{}

### 2.性能调优实战

#### 2.1.简介

**性能调优原则**

- 要依靠数据而不是猜测
- 要定位最大瓶颈而不是细枝末节
- 不要过早优化
- 不要过度优化

#### 2.2.性能分析工具pprof

希望知道应用在什么地方耗费了多少CPU、Memory

pprof是用于可视化和分析性能分析数据的工具

![image-20230120164903970](https://raw.githubusercontent.com/moon-xuans/mediaImage/main/2022/image-20230120164903970.png)

